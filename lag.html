<!-- ADD: Feature Tray (Tap a feature, then click on blueprint to place) -->
<div id="tray" class="tray" style="display:none;" role="region" aria-label="Add and edit items">
  <div class="trayTitle">Add Items</div>

  <div class="trayBtns" role="toolbar" aria-label="Feature tools">
    <button class="btn" data-place="pool" aria-pressed="false" title="Pool (1)">üèä Pool</button>
    <button class="btn" data-place="zen"  aria-pressed="false" title="Zen Garden (2)">ü™® Zen</button>
    <button class="btn" data-place="path" aria-pressed="false" title="Path (3)">üß± Path</button>
    <button class="btn" data-place="deck" aria-pressed="false" title="Deck (4)">ü™µ Deck</button>
    <button class="btn" data-place="perg" aria-pressed="false" title="Pergola (5)">üß± Pergola</button>
    <button class="btn" data-place="fire" aria-pressed="false" title="Fire Pit (6)">üî• Fire Pit</button>
    <button class="btn" data-place="beds" aria-pressed="false" title="Beds (7)">üåø Beds</button>
    <button id="cancelPlace" class="btn" title="Cancel (Esc)">‚úñ Cancel</button>
  </div>

  <div class="trayOpts">
    <label class="toggle">
      <input id="multiPlace" type="checkbox" />
      <span>Keep placing</span>
    </label>
    <label class="toggle">
      <input id="snapGrid" type="checkbox" checked />
      <span>Snap to grid (16px)</span>
    </label>
  </div>

  <div class="trayActions">
    <button id="rotateLeft" class="btn btnSm" title="Rotate -6¬∞ ([)">‚ü≤</button>
    <button id="rotateRight" class="btn btnSm" title="Rotate +6¬∞ (])">‚ü≥</button>
    <button id="deleteItem" class="btn btnSm" title="Delete (Del)">üóë</button>
    <button id="exportJson" class="btn btnSm" title="Export JSON">‚§ì Export</button>
    <label class="btn btnSm fileLbl" title="Import JSON">
      ‚§í Import
      <input id="importJson" type="file" accept="application/json" hidden />
    </label>
  </div>

  <div class="small" aria-live="polite">
    Tip: Tap a feature ‚Üí click on blueprint to place a hologram.
    <span class="muted">Shortcuts: 1‚Äì7 tools, R rotate, Del delete, Esc cancel, Alt+Drag duplicate</span>
  </div>
</div>
/* ADD: Feature Tray UI */
.tray{
  position:absolute;
  left:14px;
  bottom:14px;
  z-index:13;
  width:440px;
  max-width:92vw;
  background:#0b1533cc;
  border:1px solid #1e2a4c;
  border-radius:12px;
  padding:10px;
  backdrop-filter: blur(7px);
  color:#dbe9ff;
  font: 500 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
}
.trayTitle{
  font-weight:800;
  margin-bottom:8px;
  color:#dbe9ff;
}
.trayBtns, .trayActions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:6px;
}
.trayOpts{
  display:flex;
  gap:12px;
  align-items:center;
  margin:6px 0 8px;
}
.toggle{
  display:flex;
  align-items:center;
  gap:6px;
  opacity:0.9;
}
.btn{
  appearance:none;
  border:1px solid #253359;
  background:#0f1b3dcc;
  color:#e5f0ff;
  padding:8px 10px;
  border-radius:8px;
  cursor:pointer;
  transition:background .12s ease, border-color .12s ease, transform .04s ease;
}
.btn[aria-pressed="true"]{
  background:#142758;
  border-color:#3b59a6;
  box-shadow: 0 0 0 1px #3b59a6 inset;
}
.btn:hover{ background:#13224b; }
.btn:active{ transform: translateY(1px); }
.btnSm{ padding:6px 8px; font-size:13px; }
.fileLbl{ position:relative; overflow:hidden; }
.fileLbl input{ position:absolute; inset:0; opacity:0; cursor:pointer; }

.small{ font-size:12px; opacity:.9; }
.small .muted{ opacity:.7; }

/* Focus ring accessibility */
.btn:focus-visible, .toggle input:focus-visible + span{
  outline: 2px solid #66a3ff;
  outline-offset: 2px;
  border-radius:6px;
}

/* Hologram effect (SVG) */
@keyframes holoPulse{
  0%,100% { filter: drop-shadow(0 0 10px rgba(103,232,249,.20)) drop-shadow(0 0 22px rgba(96,165,250,.18)); }
  50%     { filter: drop-shadow(0 0 16px rgba(103,232,249,.55)) drop-shadow(0 0 35px rgba(96,165,250,.35)); }
}
@keyframes holoDash { to { stroke-dashoffset: -60; } }

g.holoActive *{
  animation: holoDash 1.2s linear infinite;
  stroke-dasharray: 10 10;
  will-change: filter, stroke-dashoffset;
}
g.holoActive{
  animation: holoPulse .9s ease-in-out infinite;
  opacity: 0.95;
}

/* Selected item outline (non-destructive) */
g[data-selected="true"] { filter: drop-shadow(0 0 0.6px rgba(255,255,255,.18)); }
g[data-selected="true"] > .__selOutline__{
  pointer-events: none;
  fill: none;
  stroke: #9ec1ff;
  stroke-width: 2;
  stroke-dasharray: 6 6;
  opacity: .9;
}

/* Ghost shouldn‚Äôt eat pointer events */
g[data-ghost="true"]{ pointer-events: none; }

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce){
  g.holoActive, g.holoActive *{ animation: none !important; }
}
// ===== Module: Holographic Placement (improved) =====
(() => {
  // --- Config ---
  const GRID = 16;            // grid size in px (SVG units)
  const ROT_STEP = 6;         // default rotation step
  const PREC_STEP = 1;        // precise rotation step with Shift or [ ]
  const AUTOSAVE_KEY = 'blueprint_layout_v1';

  // --- DOM refs ---
  const tray = document.getElementById("tray");
  const cancelPlaceBtn = document.getElementById("cancelPlace");
  const multiPlaceChk = document.getElementById("multiPlace");
  const snapGridChk   = document.getElementById("snapGrid");
  const rotateLeftBtn = document.getElementById("rotateLeft");
  const rotateRightBtn= document.getElementById("rotateRight");
  const deleteBtn     = document.getElementById("deleteItem");
  const exportBtn     = document.getElementById("exportJson");
  const importInput   = document.getElementById("importJson");

  // Detect SVG root
  let svg = window.svg || document.querySelector('svg');
  if(!svg){
    console.warn("No <svg> found. Ensure your blueprint SVG exists before this script runs.");
    return;
  }

  // Provide safe fallbacks if your helpers are not present
  const elem = window.elem || ((tag, attrs={}) => {
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  });
  const textAt = window.textAt || ((str, x, y) => {
    const t = elem("text", {x, y, "text-anchor":"start", "dominant-baseline":"middle", fill:"#e8f3ff", "font-size":"14", "font-weight":"700"});
    t.textContent = str;
    return t;
  });
  const hexToRgba = window.hexToRgba || ((hex, a=1) => {
    const v = hex.replace('#','');
    const bigint = parseInt(v.length===3 ? v.split('').map(c=>c+c).join('') : v, 16);
    const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
    return `rgba(${r},${g},${b},${a})`;
  });

  // State
  let placeMode = null; // "pool" | "zen" | ...
  let ghost = null;     // hologram preview group
  let activeItem = null;
  let dragging = false;
  let dragBase = {x:0,y:0};
  let itemPos  = {x:0,y:0};
  let itemRot  = 0;

  // Show tray once blueprint is generated (preserve your original)
  if (typeof window.generate === "function") {
    const _oldGenerate = window.generate;
    window.generate = function(isRegen=false){
      _oldGenerate(isRegen);
      tray.style.display = "block";
      // Optional: try restoring autosave
      tryRestoreLayout();
    };
  } else {
    // If no generate() hook, still show tray
    tray.style.display = "block";
    tryRestoreLayout();
  }

  // Utilities
  function svgPoint(evt){
    const p = svg.createSVGPoint();
    p.x = evt.clientX;
    p.y = evt.clientY;
    return p.matrixTransform(svg.getScreenCTM().inverse());
  }
  function makeHolo(g, on=true){
    g.classList.toggle("holoActive", !!on);
  }
  function clearGhost(){
    if(ghost?.parentNode) ghost.parentNode.removeChild(ghost);
    ghost = null;
  }
  function selectItem(g){
    // Deselect previous
    if(activeItem){
      activeItem.removeAttribute("data-selected");
      // Remove selection outline element if present
      const oldOutline = activeItem.querySelector(":scope > .__selOutline__");
      if(oldOutline) oldOutline.remove();
    }

    activeItem = g || null;
    if(!activeItem) return;

    activeItem.setAttribute("data-selected", "true");
    // Bring to front
    svg.appendChild(activeItem);

    // Add non-destructive selection outline that follows transform
    const outline = elem("rect", { class: "__selOutline__" });
    // Use bounding box of group's *untransformed* children then rely on group transform
    const bb = activeItem.getBBox();
    outline.setAttribute("x", bb.x - 4);
    outline.setAttribute("y", bb.y - 4);
    outline.setAttribute("width", bb.width + 8);
    outline.setAttribute("height", bb.height + 8);
    activeItem.appendChild(outline);
  }
  function snap(v){ return snapGridChk?.checked ? Math.round(v / GRID) * GRID : v; }

  // Transform apply ‚Äî rotate around cached center for performance
  function setTransform(g, x, y, rotDeg){
    g.dataset.tx = String(x);
    g.dataset.ty = String(y);
    g.dataset.rot = String(rotDeg);

    let cx = parseFloat(g.dataset.cx || "NaN");
    let cy = parseFloat(g.dataset.cy || "NaN");
    if(Number.isNaN(cx) || Number.isNaN(cy)){
      // compute once, cache center in local coords
      const bb = g.getBBox();
      cx = bb.x + bb.width/2;
      cy = bb.y + bb.height/2;
      g.dataset.cx = String(cx);
      g.dataset.cy = String(cy);
    }
    g.setAttribute("transform", `translate(${x},${y}) rotate(${rotDeg} ${cx} ${cy})`);
  }

  // Constrain to SVG viewBox when present
  function clampToViewBox(x, y){
    const vb = svg.viewBox.baseVal;
    if(!vb || vb.width === 0 || vb.height === 0) return {x,y};
    // We‚Äôll only clamp the translate origin into the viewBox; items can overflow slightly.
    const cx = Math.max(vb.x, Math.min(x, vb.x + vb.width));
    const cy = Math.max(vb.y, Math.min(y, vb.y + vb.height));
    return {x:cx, y:cy};
  }

  // Build features (re-uses your color pickers if present)
  function createFeature(type){
    const g = elem("g", {"data-type": type});
    const stroke = "#67e8f9";

    const color = (id, fallback) => document.getElementById(id)?.value || fallback;
    const fill  = (hex, a) => hexToRgba(hex, a);

    const COL = {
      pool: color("c_pool", "#60A5FA"),
      zen:  color("c_zen",  "#22D3EE"),
      path: color("c_path", "#93C5FD"),
      deck: color("c_deck", "#A78BFA"),
      perg: color("c_perg", "#7DD3FC"),
      fire: color("c_fire", "#F59E0B"),
      beds: color("c_beds", "#34D399"),
    };

    if(type === "pool"){
      const cx=0, cy=0, rx=140, ry=100;
      g.appendChild(elem("ellipse",{cx,cy,rx,ry, fill:fill(COL.pool,.20), stroke, "stroke-width":3}));
      for(let i=0;i<4;i++){
        g.appendChild(elem("ellipse",{cx,cy,rx:rx-i*18,ry:ry-i*10,fill:"none",stroke:COL.pool,"stroke-opacity":.45,"stroke-dasharray":"2 10"}));
      }
      g.appendChild(textAt("POOL", cx-18, cy));
    }
    if(type === "zen"){
      const x=-140, y=-180, w=280, h=360;
      g.appendChild(elem("rect",{x,y,width:w,height:h,rx:18,ry:18, fill:fill(COL.zen,.12), stroke, "stroke-width":2}));
      for(let i=y+14;i<y+h-10;i+=16){
        g.appendChild(elem("path",{d:`M ${x+10} ${i} Q ${x+w/2} ${i-6} ${x+w-10} ${i}`, fill:"none", stroke:COL.zen, "stroke-opacity":.6}));
      }
      for(let i=0;i<6;i++){
        const cx = x + 20 + Math.random()*(w-40);
        const cy = y + 20 + Math.random()*(h-40);
        g.appendChild(elem("ellipse",{cx,cy,rx:8+Math.random()*10,ry:6+Math.random()*8, fill:COL.zen, "fill-opacity":.85}));
      }
      g.appendChild(textAt("ZEN", -18, 0));
    }
    if(type === "path"){
      const pavers = [{x:-40,y:-10},{x:0,y:-10},{x:40,y:-10},{x:-20,y:20},{x:20,y:20}];
      pavers.forEach(p=>{
        g.appendChild(elem("rect",{x:p.x,y:p.y,width:32,height:20,rx:6,ry:6, fill:fill(COL.path,.20), stroke:COL.path, "stroke-opacity":.9, "stroke-width":1}));
      });
      g.appendChild(textAt("PATH", -18, 52));
    }
    if(type === "deck"){
      const x=-160, y=-90, w=320, h=180;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:fill(COL.deck,.18), stroke, "stroke-width":2}));
      for(let i=x+8;i<x+w;i+=14){
        g.appendChild(elem("line",{x1:i,y1:y+4,x2:i,y2:y+h-4, stroke:COL.deck, "stroke-opacity":.22, "stroke-width":1}));
      }
      g.appendChild(textAt("DECK", -16, 0));
    }
    if(type === "perg"){
      const x=-150, y=-80, w=300, h=160;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:"none", stroke:COL.perg, "stroke-width":2, "stroke-dasharray":"6 6"}));
      for(let i=y+12;i<y+h;i+=18){
        g.appendChild(elem("line",{x1:x+6,y1:i,x2:x+w-6,y2:i, stroke:COL.perg, "stroke-opacity":.55, "stroke-width":1}));
      }
      const posts = [{cx:x+14,cy:y+14},{cx:x+w-14,cy:y+14},{cx:x+14,cy:y+h-14},{cx:x+w-14,cy:y+h-14}];
      posts.forEach(p=>g.appendChild(elem("circle",{cx:p.cx,cy:p.cy,r:5,fill:COL.perg,"fill-opacity":.85})));
      g.appendChild(textAt("PERG", -16, 0));
    }
    if(type === "fire"){
      const cx=0, cy=0;
      g.appendChild(elem("circle",{cx,cy,r:36,fill:"none",stroke, "stroke-width":2}));
      g.appendChild(elem("circle",{cx,cy,r:18,fill:fill(COL.fire,.18),stroke:COL.fire,"stroke-dasharray":"4 6"}));
      g.appendChild(textAt("FIRE", -14, 54));
    }
    if(type === "beds"){
      const x=-160, y=-20, w=320, h=40;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:fill(COL.beds,.15), stroke, "stroke-dasharray":"3 6"}));
      for(let i=x+6;i<x+w-6;i+=12){
        g.appendChild(elem("line",{x1:i,y1:y+6,x2:i,y2:y+h-6, stroke:COL.beds, "stroke-opacity":.25, "stroke-width":1}));
      }
      g.appendChild(textAt("BEDS", -18, 62));
    }
    return g;
  }

  // --- Placement UI state ---
  function setActiveTool(btn){
    // Unpress all
    tray.querySelectorAll('button[data-place][aria-pressed="true"]').forEach(b=>{
      b.setAttribute('aria-pressed', 'false');
    });
    if(btn){
      btn.setAttribute('aria-pressed', 'true');
    }
  }

  // Tray tool click => placement mode
  tray.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-place]");
    if(!btn) return;

    placeMode = btn.dataset.place;
    setActiveTool(btn);

    // Create ghost hologram
    clearGhost();
    ghost = createFeature(placeMode);
    ghost.style.opacity = "0.65";
    ghost.setAttribute("data-ghost", "true");
    makeHolo(ghost, true);
    svg.appendChild(ghost);

    // Start with center-ish
    const vb = svg.viewBox.baseVal;
    const startX = vb?.width ? vb.x + vb.width/2 : 600;
    const startY = vb?.height ? vb.y + vb.height/2 : 400;
    setTransform(ghost, startX, startY, 0);
  });

  cancelPlaceBtn.addEventListener("click", () => {
    placeMode = null; clearGhost(); setActiveTool(null);
  });

  // Pointer move: ghost follows pointer
  svg.addEventListener("pointermove", (e) => {
    if(placeMode && ghost){
      const pt = svgPoint(e);
      const x = snap(pt.x), y = snap(pt.y);
      setTransform(ghost, x, y, 0);
    }
    if(!dragging || !activeItem) return;
    const pt = svgPoint(e);
    let x = pt.x - dragBase.x;
    let y = pt.y - dragBase.y;
    if(snapGridChk?.checked){ x = snap(x); y = snap(y); }
    ({x, y} = clampToViewBox(x, y));
    setTransform(activeItem, x, y, itemRot);
  });

  // Pointer down: place OR select/drag
  svg.addEventListener("pointerdown", (e) => {
    if(e.button !== 0) return; // left click only
    const targetGroup = e.target.closest("g");

    // If in placement mode => PLACE the item
    if(placeMode && ghost){
      e.preventDefault();
      const pt = svgPoint(e);
      let x = snap(pt.x), y = snap(pt.y);
      ({x,y} = clampToViewBox(x,y));

      const real = createFeature(placeMode);
      svg.appendChild(real);
      setTransform(real, x, y, 0);
      selectItem(real);

      // duplicate via Alt+Click as immediate second placement
      if(!multiPlaceChk?.checked){
        // Exit placement after one
        placeMode = null; clearGhost(); setActiveTool(null);
      }
      autoSave();
      return;
    }

    // Otherwise: select + drag existing item
    if(targetGroup && !targetGroup.hasAttribute("data-ghost")){
      selectItem(targetGroup);

      dragging = true;
      const pt = svgPoint(e);

      const tx = parseFloat(targetGroup.dataset.tx || "0");
      const ty = parseFloat(targetGroup.dataset.ty || "0");
      const rot = parseFloat(targetGroup.dataset.rot || "0");
      itemPos = {x:tx, y:ty};
      itemRot = rot;

      dragBase.x = pt.x - tx;
      dragBase.y = pt.y - ty;

      // Alt+Drag = duplicate then drag the clone
      if(e.altKey){
        const clone = targetGroup.cloneNode(true);
        // Clean selection outline in clone if any
        const outline = clone.querySelector(":scope > .__selOutline__");
        if(outline) outline.remove();
        svg.appendChild(clone);
        selectItem(clone);
      }

      svg.setPointerCapture?.(e.pointerId);
    } else {
      // Clicked empty space
      selectItem(null);
    }
  });

  // Pointer up: end drag
  svg.addEventListener("pointerup", (e) => {
    if(dragging){ autoSave(); }
    dragging = false;
  });

  // Wheel: rotate selected item
  svg.addEventListener("wheel", (e) => {
    if(!activeItem) return;
    e.preventDefault();
    const step = e.shiftKey ? PREC_STEP : ROT_STEP;
    const delta = Math.sign(e.deltaY);
    itemRot += delta * step;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  }, {passive:false});

  // Hover holo (skip ghost)
  svg.addEventListener("pointerover", (e) => {
    const g = e.target.closest("g");
    if(!g || g.hasAttribute("data-ghost")) return;
    makeHolo(g, true);
  });
  svg.addEventListener("pointerout", (e) => {
    const g = e.target.closest("g");
    if(!g || g === activeItem) return;
    makeHolo(g, false);
  });

  // Buttons: rotate/delete
  rotateLeftBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    itemRot -= ROT_STEP;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  });
  rotateRightBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    itemRot += ROT_STEP;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  });
  deleteBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    const next = activeItem.nextElementSibling || activeItem.previousElementSibling;
    activeItem.remove(); activeItem = null;
    selectItem(next?.closest?.("g") || null);
    autoSave();
  });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    // Tools 1-7
    const toolMap = { '1':'pool','2':'zen','3':'path','4':'deck','5':'perg','6':'fire','7':'beds' };
    if(toolMap[e.key]){
      const btn = tray.querySelector(`button[data-place="${toolMap[e.key]}"]`);
      if(btn){ btn.click(); }
      return;
    }
    // Esc cancel
    if(e.key === "Escape"){
      placeMode = null; clearGhost(); setActiveTool(null);
      selectItem(null);
      return;
    }
    // Delete / Backspace
    if((e.key === "Delete" || e.key === "Backspace") && activeItem){
      deleteBtn?.click();
      e.preventDefault();
      return;
    }
    // Rotation
    if(activeItem && (e.key.toLowerCase() === "r" || e.key === "[" || e.key === "]")){
      const step = (e.shiftKey || e.key==="[" || e.key==="]") ? PREC_STEP : ROT_STEP;
      if(e.key === "[" ) itemRot -= step;
      else if(e.key === "]") itemRot += step;
      else if(e.key.toLowerCase() === "r") itemRot += step;

      const tx = parseFloat(activeItem.dataset.tx || "0");
      const ty = parseFloat(activeItem.dataset.ty || "0");
      setTransform(activeItem, tx, ty, itemRot);
      autoSave();
    }
  });

  // Export / Import JSON
  exportBtn?.addEventListener("click", () => {
    const data = serializeLayout();
    const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "blueprint_layout.json";
    a.click();
    URL.revokeObjectURL(a.href);
  });

  importInput?.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const text = await file.text();
    try{
      const data = JSON.parse(text);
      clearAllPlaced();
      deserializeLayout(data);
      autoSave();
    }catch(err){
      console.error("Invalid JSON:", err);
      alert("Invalid layout JSON.");
    }finally{
      importInput.value = "";
    }
  });

  // Serialization (type, x, y, rot)
  function serializeLayout(){
    const arr = [];
    svg.querySelectorAll("g[data-type]:not([data-ghost='true'])").forEach(g=>{
      arr.push({
        type: g.dataset.type,
        x: parseFloat(g.dataset.tx || "0"),
        y: parseFloat(g.dataset.ty || "0"),
        rot: parseFloat(g.dataset.rot || "0"),
      });
    });
    return { version:1, items: arr };
  }
  function deserializeLayout(data){
    if(!data?.items) return;
    for(const it of data.items){
      const g = createFeature(it.type);
      svg.appendChild(g);
      setTransform(g, it.x, it.y, it.rot || 0);
    }
  }
  function clearAllPlaced(){
    svg.querySelectorAll("g[data-type]:not([data-ghost='true'])").forEach(g=>g.remove());
    selectItem(null);
  }

  // Autosave / restore (optional)
  function autoSave(){
    try{ localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(serializeLayout())); }catch{}
  }
  function tryRestoreLayout(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      deserializeLayout(data);
    }catch{}
  }
})();
<!-- MATERIALS PANEL -->
<div id="materialsPanel" class="materials" style="display:none;" role="region" aria-label="Materials needed">
  <div class="matHeader">
    <div class="matTitle">Materials</div>
    <button id="exportCsv" class="btn btnSm" title="Export CSV">‚§ì CSV</button>
  </div>

  <div class="matControls">
    <label class="ctrlRow">
      <span>Scale:</span>
      <input id="scaleInput" type="number" step="0.01" value="0.10" />
      <span class="unit">ft per SVG unit</span>
    </label>

    <details>
      <summary>Assumptions (click to edit)</summary>
      <div class="assumpGrid">
        <label>Path paver size (in): <input id="paverIn" type="number" value="16"></label>
        <label>Paver gap (in): <input id="paverGapIn" type="number" value="0.5"></label>
        <label>Base depth (in): <input id="baseDepthIn" type="number" value="4"></label>
        <label>Sand depth (in): <input id="sandDepthIn" type="number" value="1"></label>

        <label>Deck board width (in): <input id="deckBoardIn" type="number" value="5.5"></label>
        <label>Board gap (in): <input id="deckGapIn" type="number" value="0.125"></label>
        <label>Joist spacing (in): <input id="joistSpacingIn" type="number" value="16"></label>
        <label>Joist size (in): <input id="joistSizeIn" type="text" value="2x8"></label>

        <label>Pergola post spacing (ft): <input id="pergPostFt" type="number" value="8"></label>
        <label>Pergola post size (in): <input id="pergPostIn" type="text" value="6x6"></label>

        <label>Bed soil depth (in): <input id="soilDepthIn" type="number" value="8"></label>
        <label>Mulch depth (in): <input id="mulchDepthIn" type="number" value="3"></label>

        <label>Fire block height (in): <input id="fireBlockHIn" type="number" value="4"></label>
        <label>Fire block width (in): <input id="fireBlockWIn" type="number" value="8"></label>
        <label>Fire block thickness (in): <input id="fireBlockTIn" type="number" value="3.5"></label>
        <label>Fire pit diameter (in): <input id="firePitDIn" type="number" value="36"></label>

        <label>Pool avg depth (ft): <input id="poolDepthFt" type="number" value="4.5"></label>
        <label>Pool wall thickness (in): <input id="poolWallIn" type="number" value="6"></label>
      </div>
    </details>
  </div>

  <div class="matList" id="matList" aria-live="polite"></div>
</div>
.materials{
  position:absolute;
  right:14px;
  bottom:14px;
  z-index:13;
  width:420px;
  max-width:92vw;
  background:#0b1533cc;
  border:1px solid #1e2a4c;
  border-radius:12px;
  padding:10px;
  backdrop-filter: blur(7px);
  color:#dbe9ff;
  font: 500 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
}
.matHeader{
  display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;
}
.matTitle{ font-weight:800; }
.matControls{ margin-bottom:8px; }
.ctrlRow{ display:flex; align-items:center; gap:8px; margin-bottom:6px; }
.ctrlRow input{ width:90px; }
.unit{ opacity:.8; }
.assumpGrid{
  display:grid; grid-template-columns: repeat(2, minmax(0,1fr));
  gap:8px; margin-top:8px;
}
.assumpGrid label{ display:flex; justify-content:space-between; gap:8px; }
.assumpGrid input{ width:92px; }

.matList .group{
  border-top:1px dashed #253359; padding-top:6px; margin-top:6px;
}
.matList .groupTitle{ font-weight:700; margin-bottom:4px; }
.matList .row{ display:flex; justify-content:space-between; gap:10px; }
.matList .row .name{ opacity:.95; }
.matList .row .qty{ opacity:.95; }
.matList .subtle{ opacity:.75; font-size:12px; }        
(() => {
  const panel = document.getElementById('materialsPanel');
  const listEl = document.getElementById('matList');
  const exportCsvBtn = document.getElementById('exportCsv');

  // Inputs
  const scaleInput     = document.getElementById('scaleInput');
  const paverIn        = document.getElementById('paverIn');
  const paverGapIn     = document.getElementById('paverGapIn');
  const baseDepthIn    = document.getElementById('baseDepthIn');
  const sandDepthIn    = document.getElementById('sandDepthIn');

  const deckBoardIn    = document.getElementById('deckBoardIn');
  const deckGapIn      = document.getElementById('deckGapIn');
  const joistSpacingIn = document.getElementById('joistSpacingIn');
  const joistSizeIn    = document.getElementById('joistSizeIn');

  const pergPostFt     = document.getElementById('pergPostFt');
  const pergPostIn     = document.getElementById('pergPostIn');

  const soilDepthIn    = document.getElementById('soilDepthIn');
  const mulchDepthIn   = document.getElementById('mulchDepthIn');

  const fireBlockHIn   = document.getElementById('fireBlockHIn');
  const fireBlockWIn   = document.getElementById('fireBlockWIn');
  const fireBlockTIn   = document.getElementById('fireBlockTIn');
  const firePitDIn     = document.getElementById('firePitDIn');

  const poolDepthFt    = document.getElementById('poolDepthFt');
  const poolWallIn     = document.getElementById('poolWallIn');

  // Auto-detect SVG (same as placement script)
  let svg = window.svg || document.querySelector('svg');
  if(!svg){ console.warn("Materials: No <svg> found."); return; }

  // Show panel when tray shows
  const tray = document.getElementById("tray");
  const showPanel = () => { panel.style.display = "block"; };
  if (tray && tray.style.display !== "none") showPanel();
  const mo = new MutationObserver(() => {
    if (tray && tray.style.display !== "none") showPanel();
  });
  tray && mo.observe(tray, { attributes:true, attributeFilter:['style','class'] });

  const ftPerUnit = () => Math.max(parseFloat(scaleInput.value || "0.1"), 0.0001);

  // Helpers
  const in2ft = v => (v/12);
  const areaEllipse = (a,b) => Math.PI * a * b;
  const perimEllipseRamanujan = (a,b) => {
    const h = Math.pow(a-b,2)/Math.pow(a+b,2);
    return Math.PI*(a+b)*(1 + (3*h)/(10+Math.sqrt(4-3*h)));
  };

  // Listen to any meaningful change
  [
    scaleInput, paverIn, paverGapIn, baseDepthIn, sandDepthIn,
    deckBoardIn, deckGapIn, joistSpacingIn, joistSizeIn,
    pergPostFt, pergPostIn, soilDepthIn, mulchDepthIn,
    fireBlockHIn, fireBlockWIn, fireBlockTIn, firePitDIn,
    poolDepthFt, poolWallIn
  ].forEach(inp => inp?.addEventListener('input', recompute));

  // Recompute when items are added/removed or attributes change
  const svgObs = new MutationObserver(muts => {
    for(const m of muts){
      if(m.type === 'childList' || m.type === 'attributes'){
        recompute();
        break;
      }
    }
  });
  svgObs.observe(svg, { childList:true, subtree:true, attributes:true, attributeFilter:['transform','data-type','data-tx','data-ty','data-rot'] });

  function getGroups(){
    return Array.from(svg.querySelectorAll("g[data-type]:not([data-ghost='true'])"));
  }

  // Extract logical sizes from each group‚Äôs untransformed bbox (local size)
  function sizeForGroup(g){
    const bb = g.getBBox();
    const scale = ftPerUnit();
    return { wFt: bb.width*scale, hFt: bb.height*scale, bb }; // feet
  }

  // Compute per-feature materials (estimates)
  function materialsForGroup(g){
    const type = g.dataset.type;
    const { wFt, hFt, bb } = sizeForGroup(g);
    const mats = [];
    const add = (name, qty, unit, note='') => mats.push({ name, qty, unit, note });

    // Round helpers
    const rnd = (v, p=2) => Math.round(v*10**p)/10**p;
    const ceil = Math.ceil;

    if(type === 'path'){
      // Use pavers sized (paverIn) with gap (paverGapIn)
      const paver = in2ft(parseFloat(paverIn.value));
      const gap   = in2ft(parseFloat(paverGapIn.value));
      const pitch = paver + gap;

      const cols = Math.max(1, Math.floor(wFt / pitch));
      const rows = Math.max(1, Math.floor(hFt / pitch));
      const count = cols * rows;

      const areaFt2 = wFt * hFt;
      const baseDepthFt = in2ft(parseFloat(baseDepthIn.value));
      const sandDepthFt = in2ft(parseFloat(sandDepthIn.value));
      const baseVol = areaFt2 * baseDepthFt; // ft¬≥
      const sandVol = areaFt2 * sandDepthFt; // ft¬≥

      add('Concrete/stone pavers', count, 'pcs', `${rnd(paver*12)}" with ${rnd(gap*12)}" gaps`);
      add('Compacted base (gravel)', rnd(baseVol/27), 'yd¬≥', `${baseDepthIn.value}" depth`);
      add('Leveling sand', rnd(sandVol/27), 'yd¬≥', `${sandDepthIn.value}" depth`);
      add('Edging', rnd(2*(wFt+hFt)), 'ft', 'Optional');
    }

    if(type === 'deck'){
      // Treat rect as deck rectangle
      const boardW = in2ft(parseFloat(deckBoardIn.value));
      const boardGap = in2ft(parseFloat(deckGapIn.value));
      const joistSpacing = in2ft(parseFloat(joistSpacingIn.value));
      const joistSize = (joistSizeIn.value || '2x8').toUpperCase();

      // Boards run along width; count along height
      const boardPitch = boardW + boardGap;
      const boardCount = Math.max(1, Math.floor(hFt / boardPitch));
      add('Deck boards', boardCount, 'ea', `${rnd(wFt)} ft length, ${deckBoardIn.value}" width + ${deckGapIn.value}" gap`);

      // Joists run along height; spacing across width
      const joistCount = Math.max(2, Math.floor(wFt / joistSpacing) + 1);
      add(`Joists (${joistSize})`, joistCount, 'ea', `${rnd(hFt)} ft length @ ${joistSpacingIn.value}" OC`);

      // Rim joists / perimeter
      add('Rim/ledger boards', 2, 'ea', `${rnd(hFt)} ft length (front/back)`);
      add('Rim boards (sides)', 2, 'ea', `${rnd(wFt)} ft length (left/right)`);

      // Posts estimate: grid every ~6‚Äì8 ft
      const span = 6; // ft
      const postCols = Math.max(2, Math.ceil(wFt / span));
      const postRows = Math.max(2, Math.ceil(hFt / span));
      add('Posts (4x4 or 6x6)', postCols*postRows, 'ea', `~${span} ft grid; adjust for beam layout`);

      // Fasteners / hardware (rough lump sums)
      add('Deck screws', boardCount * Math.ceil(wFt / 1.5) * 2, 'pcs', 'Approximation');
      add('Joist hangers', joistCount*2, 'ea', 'Both ends');
      add('Concrete for footings', rnd((postCols*postRows*0.6)), 'yd¬≥', '~0.6 ft¬≥ per footing typical');
    }

    if(type === 'perg'){
      // Rect with posts in corners plus spacing grid
      const postSpacingFt = parseFloat(pergPostFt.value);
      const postSize = (pergPostIn.value || '6x6').toUpperCase();

      const cols = Math.max(2, Math.ceil(wFt / postSpacingFt) + 1);
      const rows = Math.max(2, Math.ceil(hFt / postSpacingFt) + 1);
      const postCount = cols * rows;
      add(`Posts (${postSize})`, postCount, 'ea', `${postSpacingFt} ft target spacing`);

      // Beams along length & width
      add('Beams', cols * 2 + rows * 2, 'ea', 'Top perimeter + interior rows/cols');
      add('Rafters', Math.ceil(wFt/1.5), 'ea', '~18" spacing');
      add('Anchors / footings', postCount, 'ea');
      add('Hardware (brackets/bolts)', postCount*4, 'pcs', 'Approx.');
    }

    if(type === 'beds'){
      // Rect area
      const areaFt2 = wFt * hFt;
      const soilDepthFt = in2ft(parseFloat(soilDepthIn.value));
      const mulchDepthFt = in2ft(parseFloat(mulchDepthIn.value));
      const soilVolYd3 = (areaFt2 * soilDepthFt)/27;
      const mulchVolYd3 = (areaFt2 * mulchDepthFt)/27;

      add('Topsoil/raised bed mix', rnd(soilVolYd3), 'yd¬≥', `${soilDepthIn.value}" depth`);
      add('Mulch', rnd(mulchVolYd3), 'yd¬≥', `${mulchDepthIn.value}" depth`);
      add('Edging', rnd(2*(wFt+hFt)), 'ft', 'Optional border');
    }

    if(type === 'fire'){
      // We provided a 36" inner circle by default; let the inputs drive it
      const dIn = parseFloat(firePitDIn.value);
      const radiusFt = in2ft(dIn)/2;
      const circumferenceFt = 2*Math.PI*radiusFt;
      const blockWft = in2ft(parseFloat(fireBlockWIn.value));
      const blockHft = in2ft(parseFloat(fireBlockHIn.value));
      const blockTft = in2ft(parseFloat(fireBlockTIn.value));
      const blocksPerCourse = Math.max(1, Math.round(circumferenceFt / blockWft));
      const courseCount = Math.max(1, Math.round((in2ft(12)) / blockHft)); // ~12" wall height default
      const totalBlocks = blocksPerCourse * courseCount;

      add('Fire pit wall blocks', totalBlocks, 'pcs', `${blocksPerCourse}/course √ó ${courseCount} courses`);
      add('Fire ring insert', 1, 'ea', `${dIn}" nominal`);
      add('Gravel base', rnd((circumferenceFt*blockTft*in2ft(4))/27), 'yd¬≥', `~4" depth under ring`);
      add('Adhesive', courseCount, 'tubes', '1 tube per course (approx.)');
    }

    if(type === 'zen'){
      // Treat as rectangular zen garden area
      const areaFt2 = wFt * hFt;
      add('Raking gravel/sand', rnd(areaFt2/3), 'tons', '1 ton covers ~300 ft¬≤ @ 2"'); // rough
      add('Edging/timber frame', rnd(2*(wFt+hFt)), 'ft', 'Optional border');
      add('Accent stones/boulders', 6, 'ea', 'As desired');
      add('Weed barrier fabric', rnd(areaFt2), 'ft¬≤', '');
    }

    if(type === 'pool'){
      // Ellipse representing pool (rx,ry from bbox halves)
      const a = (bb.width/2) * ftPerUnit();
      const b = (bb.height/2) * ftPerUnit();
      const surfaceArea = areaEllipse(a,b); // ft¬≤ water surface
      const depthFt = Math.max(1, parseFloat(poolDepthFt.value));
      const volumeFt3 = surfaceArea * depthFt;
      const gallons = volumeFt3 * 7.48052;

      // Perimeter for coping/walls
      const perimeter = perimEllipseRamanujan(a,b);

      // Walls (thickness)
      const wallT = in2ft(parseFloat(poolWallIn.value));
      const wallVolFt3 = perimeter * depthFt * wallT;

      add('Excavation', Math.round(volumeFt3), 'ft¬≥', `~${depthFt} ft avg depth`);
      add('Pool water', Math.round(gallons), 'gal', 'Approximate');
      add('Concrete (walls/floor)', Math.round((wallVolFt3 + surfaceArea*in2ft(6))/27), 'yd¬≥', '6" slab floor + walls (very rough)');
      add('Coping/edge', Math.round(perimeter), 'ft', 'Linear feet');
      add('Rebar', Math.round(perimeter*2 + surfaceArea*0.5), 'ft', 'Very rough placeholder');
      add('Plumbing kit & pump/filter', 1, 'set', 'Equipment package');
    }

    return mats;
  }

  function recompute(){
    const groups = getGroups();
    const byFeature = {};
    const totals = {};

    for(const g of groups){
      const type = g.dataset.type;
      const mats = materialsForGroup(g);
      if(!byFeature[type]) byFeature[type] = [];
      byFeature[type].push(mats);

      // Accumulate global totals by material name+unit
      for(const m of mats){
        const key = `${m.name}__${m.unit}`;
        totals[key] = totals[key] || { name:m.name, unit:m.unit, qty:0 };
        totals[key].qty += Number(m.qty) || 0;
      }
    }

    render(byFeature, totals);
  }

  function render(byFeature, totals){
    const frag = document.createDocumentFragment();

    // Overall totals
    const totalsDiv = document.createElement('div');
    totalsDiv.className = 'group';
    const title = document.createElement('div');
    title.className = 'groupTitle';
    title.textContent = 'Total materials';
    totalsDiv.appendChild(title);

    Object.values(totals).forEach(t => {
      const row = document.createElement('div');
      row.className = 'row';
      const name = document.createElement('div'); name.className = 'name'; name.textContent = t.name;
      const qty  = document.createElement('div'); qty.className  = 'qty'; qty.textContent = `${fmt(t.qty)} ${t.unit}`;
      row.appendChild(name); row.appendChild(qty);
      totalsDiv.appendChild(row);
    });
    frag.appendChild(totalsDiv);

    // Breakdown by feature type
    for(const [type, arr] of Object.entries(byFeature)){
      const groupDiv = document.createElement('div');
      groupDiv.className = 'group';
      const head = document.createElement('div');
      head.className = 'groupTitle';
      head.textContent = labelForType(type) + ` (${arr.length})`;
      groupDiv.appendChild(head);

      // Sum within this type
      const typeTotals = {};
      for(const mats of arr){
        for(const m of mats){
          const key = `${m.name}__${m.unit}`;
          typeTotals[key] = typeTotals[key] || { name:m.name, unit:m.unit, qty:0, note:m.note };
          typeTotals[key].qty += Number(m.qty) || 0;
        }
      }
      Object.values(typeTotals).forEach(t => {
        const row = document.createElement('div');
        row.className = 'row';
        const name = document.createElement('div'); name.className = 'name'; name.textContent = t.name;
        const qty  = document.createElement('div'); qty.className  = 'qty'; qty.textContent = `${fmt(t.qty)} ${t.unit}`;
        row.appendChild(name); row.appendChild(qty);
        groupDiv.appendChild(row);
        if(t.note){
          const note = document.createElement('div');
          note.className = 'subtle';
          note.textContent = t.note;
          groupDiv.appendChild(note);
        }
      });

      frag.appendChild(groupDiv);
    }

    listEl.innerHTML = '';
    listEl.appendChild(frag);
  }

  function labelForType(t){
    return ({
      pool:'Pool', zen:'Zen Garden', path:'Path', deck:'Deck',
      perg:'Pergola', fire:'Fire Pit', beds:'Planting Beds'
    })[t] || t;
  }
  function fmt(v){
    // smart rounding for counts/lengths/volumes
    if (Math.abs(v) >= 100) return Math.round(v);
    if (Math.abs(v) >= 10) return Math.round(v*10)/10;
    return Math.round(v*100)/100;
  }

  // CSV export
  exportCsvBtn?.addEventListener('click', () => {
    const groups = Array.from(svg.querySelectorAll("g[data-type]:not([data-ghost='true'])"));
    const rows = [['Feature','Material','Qty','Unit','Note']];

    for(const g of groups){
      const type = labelForType(g.dataset.type);
      const mats = materialsForGroup(g);
      for(const m of mats){
        rows.push([type, m.name, String(m.qty), m.unit, m.note || '']);
      }
    }
    const csv = rows.map(r => r.map(x => `"${String(x).replaceAll('"','""')}"`).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'materials.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // Initial compute
  recompute();
})();
