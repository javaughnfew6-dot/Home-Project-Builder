<!-- ADD: Feature Tray (Tap a feature, then click on blueprint to place) -->
<div id="tray" class="tray" style="display:none;" role="region" aria-label="Add and edit items">
  <div class="trayTitle">Add Items</div>

  <div class="trayBtns" role="toolbar" aria-label="Feature tools">
    <button class="btn" data-place="pool" aria-pressed="false" title="Pool (1)">üèä Pool</button>
    <button class="btn" data-place="zen"  aria-pressed="false" title="Zen Garden (2)">ü™® Zen</button>
    <button class="btn" data-place="path" aria-pressed="false" title="Path (3)">üß± Path</button>
    <button class="btn" data-place="deck" aria-pressed="false" title="Deck (4)">ü™µ Deck</button>
    <button class="btn" data-place="perg" aria-pressed="false" title="Pergola (5)">üß± Pergola</button>
    <button class="btn" data-place="fire" aria-pressed="false" title="Fire Pit (6)">üî• Fire Pit</button>
    <button class="btn" data-place="beds" aria-pressed="false" title="Beds (7)">üåø Beds</button>
    <button id="cancelPlace" class="btn" title="Cancel (Esc)">‚úñ Cancel</button>
  </div>

  <div class="trayOpts">
    <label class="toggle">
      <input id="multiPlace" type="checkbox" />
      <span>Keep placing</span>
    </label>
    <label class="toggle">
      <input id="snapGrid" type="checkbox" checked />
      <span>Snap to grid (16px)</span>
    </label>
  </div>

  <div class="trayActions">
    <button id="rotateLeft" class="btn btnSm" title="Rotate -6¬∞ ([)">‚ü≤</button>
    <button id="rotateRight" class="btn btnSm" title="Rotate +6¬∞ (])">‚ü≥</button>
    <button id="deleteItem" class="btn btnSm" title="Delete (Del)">üóë</button>
    <button id="exportJson" class="btn btnSm" title="Export JSON">‚§ì Export</button>
    <label class="btn btnSm fileLbl" title="Import JSON">
      ‚§í Import
      <input id="importJson" type="file" accept="application/json" hidden />
    </label>
  </div>

  <div class="small" aria-live="polite">
    Tip: Tap a feature ‚Üí click on blueprint to place a hologram.
    <span class="muted">Shortcuts: 1‚Äì7 tools, R rotate, Del delete, Esc cancel, Alt+Drag duplicate</span>
  </div>
</div>
/* ADD: Feature Tray UI */
.tray{
  position:absolute;
  left:14px;
  bottom:14px;
  z-index:13;
  width:440px;
  max-width:92vw;
  background:#0b1533cc;
  border:1px solid #1e2a4c;
  border-radius:12px;
  padding:10px;
  backdrop-filter: blur(7px);
  color:#dbe9ff;
  font: 500 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
}
.trayTitle{
  font-weight:800;
  margin-bottom:8px;
  color:#dbe9ff;
}
.trayBtns, .trayActions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:6px;
}
.trayOpts{
  display:flex;
  gap:12px;
  align-items:center;
  margin:6px 0 8px;
}
.toggle{
  display:flex;
  align-items:center;
  gap:6px;
  opacity:0.9;
}
.btn{
  appearance:none;
  border:1px solid #253359;
  background:#0f1b3dcc;
  color:#e5f0ff;
  padding:8px 10px;
  border-radius:8px;
  cursor:pointer;
  transition:background .12s ease, border-color .12s ease, transform .04s ease;
}
.btn[aria-pressed="true"]{
  background:#142758;
  border-color:#3b59a6;
  box-shadow: 0 0 0 1px #3b59a6 inset;
}
.btn:hover{ background:#13224b; }
.btn:active{ transform: translateY(1px); }
.btnSm{ padding:6px 8px; font-size:13px; }
.fileLbl{ position:relative; overflow:hidden; }
.fileLbl input{ position:absolute; inset:0; opacity:0; cursor:pointer; }

.small{ font-size:12px; opacity:.9; }
.small .muted{ opacity:.7; }

/* Focus ring accessibility */
.btn:focus-visible, .toggle input:focus-visible + span{
  outline: 2px solid #66a3ff;
  outline-offset: 2px;
  border-radius:6px;
}

/* Hologram effect (SVG) */
@keyframes holoPulse{
  0%,100% { filter: drop-shadow(0 0 10px rgba(103,232,249,.20)) drop-shadow(0 0 22px rgba(96,165,250,.18)); }
  50%     { filter: drop-shadow(0 0 16px rgba(103,232,249,.55)) drop-shadow(0 0 35px rgba(96,165,250,.35)); }
}
@keyframes holoDash { to { stroke-dashoffset: -60; } }

g.holoActive *{
  animation: holoDash 1.2s linear infinite;
  stroke-dasharray: 10 10;
  will-change: filter, stroke-dashoffset;
}
g.holoActive{
  animation: holoPulse .9s ease-in-out infinite;
  opacity: 0.95;
}

/* Selected item outline (non-destructive) */
g[data-selected="true"] { filter: drop-shadow(0 0 0.6px rgba(255,255,255,.18)); }
g[data-selected="true"] > .__selOutline__{
  pointer-events: none;
  fill: none;
  stroke: #9ec1ff;
  stroke-width: 2;
  stroke-dasharray: 6 6;
  opacity: .9;
}

/* Ghost shouldn‚Äôt eat pointer events */
g[data-ghost="true"]{ pointer-events: none; }

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce){
  g.holoActive, g.holoActive *{ animation: none !important; }
}
// ===== Module: Holographic Placement (improved) =====
(() => {
  // --- Config ---
  const GRID = 16;            // grid size in px (SVG units)
  const ROT_STEP = 6;         // default rotation step
  const PREC_STEP = 1;        // precise rotation step with Shift or [ ]
  const AUTOSAVE_KEY = 'blueprint_layout_v1';

  // --- DOM refs ---
  const tray = document.getElementById("tray");
  const cancelPlaceBtn = document.getElementById("cancelPlace");
  const multiPlaceChk = document.getElementById("multiPlace");
  const snapGridChk   = document.getElementById("snapGrid");
  const rotateLeftBtn = document.getElementById("rotateLeft");
  const rotateRightBtn= document.getElementById("rotateRight");
  const deleteBtn     = document.getElementById("deleteItem");
  const exportBtn     = document.getElementById("exportJson");
  const importInput   = document.getElementById("importJson");

  // Detect SVG root
  let svg = window.svg || document.querySelector('svg');
  if(!svg){
    console.warn("No <svg> found. Ensure your blueprint SVG exists before this script runs.");
    return;
  }

  // Provide safe fallbacks if your helpers are not present
  const elem = window.elem || ((tag, attrs={}) => {
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  });
  const textAt = window.textAt || ((str, x, y) => {
    const t = elem("text", {x, y, "text-anchor":"start", "dominant-baseline":"middle", fill:"#e8f3ff", "font-size":"14", "font-weight":"700"});
    t.textContent = str;
    return t;
  });
  const hexToRgba = window.hexToRgba || ((hex, a=1) => {
    const v = hex.replace('#','');
    const bigint = parseInt(v.length===3 ? v.split('').map(c=>c+c).join('') : v, 16);
    const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
    return `rgba(${r},${g},${b},${a})`;
  });

  // State
  let placeMode = null; // "pool" | "zen" | ...
  let ghost = null;     // hologram preview group
  let activeItem = null;
  let dragging = false;
  let dragBase = {x:0,y:0};
  let itemPos  = {x:0,y:0};
  let itemRot  = 0;

  // Show tray once blueprint is generated (preserve your original)
  if (typeof window.generate === "function") {
    const _oldGenerate = window.generate;
    window.generate = function(isRegen=false){
      _oldGenerate(isRegen);
      tray.style.display = "block";
      // Optional: try restoring autosave
      tryRestoreLayout();
    };
  } else {
    // If no generate() hook, still show tray
    tray.style.display = "block";
    tryRestoreLayout();
  }

  // Utilities
  function svgPoint(evt){
    const p = svg.createSVGPoint();
    p.x = evt.clientX;
    p.y = evt.clientY;
    return p.matrixTransform(svg.getScreenCTM().inverse());
  }
  function makeHolo(g, on=true){
    g.classList.toggle("holoActive", !!on);
  }
  function clearGhost(){
    if(ghost?.parentNode) ghost.parentNode.removeChild(ghost);
    ghost = null;
  }
  function selectItem(g){
    // Deselect previous
    if(activeItem){
      activeItem.removeAttribute("data-selected");
      // Remove selection outline element if present
      const oldOutline = activeItem.querySelector(":scope > .__selOutline__");
      if(oldOutline) oldOutline.remove();
    }

    activeItem = g || null;
    if(!activeItem) return;

    activeItem.setAttribute("data-selected", "true");
    // Bring to front
    svg.appendChild(activeItem);

    // Add non-destructive selection outline that follows transform
    const outline = elem("rect", { class: "__selOutline__" });
    // Use bounding box of group's *untransformed* children then rely on group transform
    const bb = activeItem.getBBox();
    outline.setAttribute("x", bb.x - 4);
    outline.setAttribute("y", bb.y - 4);
    outline.setAttribute("width", bb.width + 8);
    outline.setAttribute("height", bb.height + 8);
    activeItem.appendChild(outline);
  }
  function snap(v){ return snapGridChk?.checked ? Math.round(v / GRID) * GRID : v; }

  // Transform apply ‚Äî rotate around cached center for performance
  function setTransform(g, x, y, rotDeg){
    g.dataset.tx = String(x);
    g.dataset.ty = String(y);
    g.dataset.rot = String(rotDeg);

    let cx = parseFloat(g.dataset.cx || "NaN");
    let cy = parseFloat(g.dataset.cy || "NaN");
    if(Number.isNaN(cx) || Number.isNaN(cy)){
      // compute once, cache center in local coords
      const bb = g.getBBox();
      cx = bb.x + bb.width/2;
      cy = bb.y + bb.height/2;
      g.dataset.cx = String(cx);
      g.dataset.cy = String(cy);
    }
    g.setAttribute("transform", `translate(${x},${y}) rotate(${rotDeg} ${cx} ${cy})`);
  }

  // Constrain to SVG viewBox when present
  function clampToViewBox(x, y){
    const vb = svg.viewBox.baseVal;
    if(!vb || vb.width === 0 || vb.height === 0) return {x,y};
    // We‚Äôll only clamp the translate origin into the viewBox; items can overflow slightly.
    const cx = Math.max(vb.x, Math.min(x, vb.x + vb.width));
    const cy = Math.max(vb.y, Math.min(y, vb.y + vb.height));
    return {x:cx, y:cy};
  }

  // Build features (re-uses your color pickers if present)
  function createFeature(type){
    const g = elem("g", {"data-type": type});
    const stroke = "#67e8f9";

    const color = (id, fallback) => document.getElementById(id)?.value || fallback;
    const fill  = (hex, a) => hexToRgba(hex, a);

    const COL = {
      pool: color("c_pool", "#60A5FA"),
      zen:  color("c_zen",  "#22D3EE"),
      path: color("c_path", "#93C5FD"),
      deck: color("c_deck", "#A78BFA"),
      perg: color("c_perg", "#7DD3FC"),
      fire: color("c_fire", "#F59E0B"),
      beds: color("c_beds", "#34D399"),
    };

    if(type === "pool"){
      const cx=0, cy=0, rx=140, ry=100;
      g.appendChild(elem("ellipse",{cx,cy,rx,ry, fill:fill(COL.pool,.20), stroke, "stroke-width":3}));
      for(let i=0;i<4;i++){
        g.appendChild(elem("ellipse",{cx,cy,rx:rx-i*18,ry:ry-i*10,fill:"none",stroke:COL.pool,"stroke-opacity":.45,"stroke-dasharray":"2 10"}));
      }
      g.appendChild(textAt("POOL", cx-18, cy));
    }
    if(type === "zen"){
      const x=-140, y=-180, w=280, h=360;
      g.appendChild(elem("rect",{x,y,width:w,height:h,rx:18,ry:18, fill:fill(COL.zen,.12), stroke, "stroke-width":2}));
      for(let i=y+14;i<y+h-10;i+=16){
        g.appendChild(elem("path",{d:`M ${x+10} ${i} Q ${x+w/2} ${i-6} ${x+w-10} ${i}`, fill:"none", stroke:COL.zen, "stroke-opacity":.6}));
      }
      for(let i=0;i<6;i++){
        const cx = x + 20 + Math.random()*(w-40);
        const cy = y + 20 + Math.random()*(h-40);
        g.appendChild(elem("ellipse",{cx,cy,rx:8+Math.random()*10,ry:6+Math.random()*8, fill:COL.zen, "fill-opacity":.85}));
      }
      g.appendChild(textAt("ZEN", -18, 0));
    }
    if(type === "path"){
      const pavers = [{x:-40,y:-10},{x:0,y:-10},{x:40,y:-10},{x:-20,y:20},{x:20,y:20}];
      pavers.forEach(p=>{
        g.appendChild(elem("rect",{x:p.x,y:p.y,width:32,height:20,rx:6,ry:6, fill:fill(COL.path,.20), stroke:COL.path, "stroke-opacity":.9, "stroke-width":1}));
      });
      g.appendChild(textAt("PATH", -18, 52));
    }
    if(type === "deck"){
      const x=-160, y=-90, w=320, h=180;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:fill(COL.deck,.18), stroke, "stroke-width":2}));
      for(let i=x+8;i<x+w;i+=14){
        g.appendChild(elem("line",{x1:i,y1:y+4,x2:i,y2:y+h-4, stroke:COL.deck, "stroke-opacity":.22, "stroke-width":1}));
      }
      g.appendChild(textAt("DECK", -16, 0));
    }
    if(type === "perg"){
      const x=-150, y=-80, w=300, h=160;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:"none", stroke:COL.perg, "stroke-width":2, "stroke-dasharray":"6 6"}));
      for(let i=y+12;i<y+h;i+=18){
        g.appendChild(elem("line",{x1:x+6,y1:i,x2:x+w-6,y2:i, stroke:COL.perg, "stroke-opacity":.55, "stroke-width":1}));
      }
      const posts = [{cx:x+14,cy:y+14},{cx:x+w-14,cy:y+14},{cx:x+14,cy:y+h-14},{cx:x+w-14,cy:y+h-14}];
      posts.forEach(p=>g.appendChild(elem("circle",{cx:p.cx,cy:p.cy,r:5,fill:COL.perg,"fill-opacity":.85})));
      g.appendChild(textAt("PERG", -16, 0));
    }
    if(type === "fire"){
      const cx=0, cy=0;
      g.appendChild(elem("circle",{cx,cy,r:36,fill:"none",stroke, "stroke-width":2}));
      g.appendChild(elem("circle",{cx,cy,r:18,fill:fill(COL.fire,.18),stroke:COL.fire,"stroke-dasharray":"4 6"}));
      g.appendChild(textAt("FIRE", -14, 54));
    }
    if(type === "beds"){
      const x=-160, y=-20, w=320, h=40;
      g.appendChild(elem("rect",{x,y,width:w,height:h, fill:fill(COL.beds,.15), stroke, "stroke-dasharray":"3 6"}));
      for(let i=x+6;i<x+w-6;i+=12){
        g.appendChild(elem("line",{x1:i,y1:y+6,x2:i,y2:y+h-6, stroke:COL.beds, "stroke-opacity":.25, "stroke-width":1}));
      }
      g.appendChild(textAt("BEDS", -18, 62));
    }
    return g;
  }

  // --- Placement UI state ---
  function setActiveTool(btn){
    // Unpress all
    tray.querySelectorAll('button[data-place][aria-pressed="true"]').forEach(b=>{
      b.setAttribute('aria-pressed', 'false');
    });
    if(btn){
      btn.setAttribute('aria-pressed', 'true');
    }
  }

  // Tray tool click => placement mode
  tray.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-place]");
    if(!btn) return;

    placeMode = btn.dataset.place;
    setActiveTool(btn);

    // Create ghost hologram
    clearGhost();
    ghost = createFeature(placeMode);
    ghost.style.opacity = "0.65";
    ghost.setAttribute("data-ghost", "true");
    makeHolo(ghost, true);
    svg.appendChild(ghost);

    // Start with center-ish
    const vb = svg.viewBox.baseVal;
    const startX = vb?.width ? vb.x + vb.width/2 : 600;
    const startY = vb?.height ? vb.y + vb.height/2 : 400;
    setTransform(ghost, startX, startY, 0);
  });

  cancelPlaceBtn.addEventListener("click", () => {
    placeMode = null; clearGhost(); setActiveTool(null);
  });

  // Pointer move: ghost follows pointer
  svg.addEventListener("pointermove", (e) => {
    if(placeMode && ghost){
      const pt = svgPoint(e);
      const x = snap(pt.x), y = snap(pt.y);
      setTransform(ghost, x, y, 0);
    }
    if(!dragging || !activeItem) return;
    const pt = svgPoint(e);
    let x = pt.x - dragBase.x;
    let y = pt.y - dragBase.y;
    if(snapGridChk?.checked){ x = snap(x); y = snap(y); }
    ({x, y} = clampToViewBox(x, y));
    setTransform(activeItem, x, y, itemRot);
  });

  // Pointer down: place OR select/drag
  svg.addEventListener("pointerdown", (e) => {
    if(e.button !== 0) return; // left click only
    const targetGroup = e.target.closest("g");

    // If in placement mode => PLACE the item
    if(placeMode && ghost){
      e.preventDefault();
      const pt = svgPoint(e);
      let x = snap(pt.x), y = snap(pt.y);
      ({x,y} = clampToViewBox(x,y));

      const real = createFeature(placeMode);
      svg.appendChild(real);
      setTransform(real, x, y, 0);
      selectItem(real);

      // duplicate via Alt+Click as immediate second placement
      if(!multiPlaceChk?.checked){
        // Exit placement after one
        placeMode = null; clearGhost(); setActiveTool(null);
      }
      autoSave();
      return;
    }

    // Otherwise: select + drag existing item
    if(targetGroup && !targetGroup.hasAttribute("data-ghost")){
      selectItem(targetGroup);

      dragging = true;
      const pt = svgPoint(e);

      const tx = parseFloat(targetGroup.dataset.tx || "0");
      const ty = parseFloat(targetGroup.dataset.ty || "0");
      const rot = parseFloat(targetGroup.dataset.rot || "0");
      itemPos = {x:tx, y:ty};
      itemRot = rot;

      dragBase.x = pt.x - tx;
      dragBase.y = pt.y - ty;

      // Alt+Drag = duplicate then drag the clone
      if(e.altKey){
        const clone = targetGroup.cloneNode(true);
        // Clean selection outline in clone if any
        const outline = clone.querySelector(":scope > .__selOutline__");
        if(outline) outline.remove();
        svg.appendChild(clone);
        selectItem(clone);
      }

      svg.setPointerCapture?.(e.pointerId);
    } else {
      // Clicked empty space
      selectItem(null);
    }
  });

  // Pointer up: end drag
  svg.addEventListener("pointerup", (e) => {
    if(dragging){ autoSave(); }
    dragging = false;
  });

  // Wheel: rotate selected item
  svg.addEventListener("wheel", (e) => {
    if(!activeItem) return;
    e.preventDefault();
    const step = e.shiftKey ? PREC_STEP : ROT_STEP;
    const delta = Math.sign(e.deltaY);
    itemRot += delta * step;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  }, {passive:false});

  // Hover holo (skip ghost)
  svg.addEventListener("pointerover", (e) => {
    const g = e.target.closest("g");
    if(!g || g.hasAttribute("data-ghost")) return;
    makeHolo(g, true);
  });
  svg.addEventListener("pointerout", (e) => {
    const g = e.target.closest("g");
    if(!g || g === activeItem) return;
    makeHolo(g, false);
  });

  // Buttons: rotate/delete
  rotateLeftBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    itemRot -= ROT_STEP;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  });
  rotateRightBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    itemRot += ROT_STEP;
    const tx = parseFloat(activeItem.dataset.tx || "0");
    const ty = parseFloat(activeItem.dataset.ty || "0");
    setTransform(activeItem, tx, ty, itemRot);
    autoSave();
  });
  deleteBtn?.addEventListener("click", () => {
    if(!activeItem) return;
    const next = activeItem.nextElementSibling || activeItem.previousElementSibling;
    activeItem.remove(); activeItem = null;
    selectItem(next?.closest?.("g") || null);
    autoSave();
  });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    // Tools 1-7
    const toolMap = { '1':'pool','2':'zen','3':'path','4':'deck','5':'perg','6':'fire','7':'beds' };
    if(toolMap[e.key]){
      const btn = tray.querySelector(`button[data-place="${toolMap[e.key]}"]`);
      if(btn){ btn.click(); }
      return;
    }
    // Esc cancel
    if(e.key === "Escape"){
      placeMode = null; clearGhost(); setActiveTool(null);
      selectItem(null);
      return;
    }
    // Delete / Backspace
    if((e.key === "Delete" || e.key === "Backspace") && activeItem){
      deleteBtn?.click();
      e.preventDefault();
      return;
    }
    // Rotation
    if(activeItem && (e.key.toLowerCase() === "r" || e.key === "[" || e.key === "]")){
      const step = (e.shiftKey || e.key==="[" || e.key==="]") ? PREC_STEP : ROT_STEP;
      if(e.key === "[" ) itemRot -= step;
      else if(e.key === "]") itemRot += step;
      else if(e.key.toLowerCase() === "r") itemRot += step;

      const tx = parseFloat(activeItem.dataset.tx || "0");
      const ty = parseFloat(activeItem.dataset.ty || "0");
      setTransform(activeItem, tx, ty, itemRot);
      autoSave();
    }
  });

  // Export / Import JSON
  exportBtn?.addEventListener("click", () => {
    const data = serializeLayout();
    const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "blueprint_layout.json";
    a.click();
    URL.revokeObjectURL(a.href);
  });

  importInput?.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const text = await file.text();
    try{
      const data = JSON.parse(text);
      clearAllPlaced();
      deserializeLayout(data);
      autoSave();
    }catch(err){
      console.error("Invalid JSON:", err);
      alert("Invalid layout JSON.");
    }finally{
      importInput.value = "";
    }
  });

  // Serialization (type, x, y, rot)
  function serializeLayout(){
    const arr = [];
    svg.querySelectorAll("g[data-type]:not([data-ghost='true'])").forEach(g=>{
      arr.push({
        type: g.dataset.type,
        x: parseFloat(g.dataset.tx || "0"),
        y: parseFloat(g.dataset.ty || "0"),
        rot: parseFloat(g.dataset.rot || "0"),
      });
    });
    return { version:1, items: arr };
  }
  function deserializeLayout(data){
    if(!data?.items) return;
    for(const it of data.items){
      const g = createFeature(it.type);
      svg.appendChild(g);
      setTransform(g, it.x, it.y, it.rot || 0);
    }
  }
  function clearAllPlaced(){
    svg.querySelectorAll("g[data-type]:not([data-ghost='true'])").forEach(g=>g.remove());
    selectItem(null);
  }

  // Autosave / restore (optional)
  function autoSave(){
    try{ localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(serializeLayout())); }catch{}
  }
  function tryRestoreLayout(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      deserializeLayout(data);
    }catch{}
  }
})();
